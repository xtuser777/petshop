/*! UIkit 3.16.24 | https://www.getuikit.com | (c) 2014 - 2023 YOOtheme | MIT License */(function(t,p){typeof exports=="object"&&typeof module<"u"?module.exports=p(require("uikit-util")):typeof define=="function"&&define.amd?define("uikittooltip",["uikit-util"],p):(t=typeof globalThis<"u"?globalThis:t||self,t.UIkitTooltip=p(t.UIkit.util))})(this,function(t){"use strict";var p={props:{container:Boolean},data:{container:!0},computed:{container({container:s}){return s===!0&&this.$container||s&&t.$(s)}}},S={props:{cls:Boolean,animation:"list",duration:Number,velocity:Number,origin:String,transition:String},data:{cls:!1,animation:[!1],duration:200,velocity:.2,origin:!1,transition:"ease",clsEnter:"uk-togglabe-enter",clsLeave:"uk-togglabe-leave"},computed:{hasAnimation({animation:s}){return!!s[0]},hasTransition({animation:s}){return["slide","reveal"].some(i=>t.startsWith(s[0],i))}},methods:{async toggleElement(s,i,e){try{return await Promise.all(t.toNodes(s).map(o=>{const n=t.isBoolean(i)?i:!this.isToggled(o);if(!t.trigger(o,"before".concat(n?"show":"hide"),[this]))return Promise.reject();const a=(t.isFunction(e)?e:e===!1||!this.hasAnimation?O:this.hasTransition?B:I)(o,n,this),r=n?this.clsEnter:this.clsLeave;t.addClass(o,r),t.trigger(o,n?"show":"hide",[this]);const c=()=>{t.removeClass(o,r),t.trigger(o,n?"shown":"hidden",[this])};return a?a.then(c,()=>(t.removeClass(o,r),Promise.reject())):c()})),!0}catch{return!1}},isToggled(s=this.$el){return s=t.toNode(s),t.hasClass(s,this.clsEnter)?!0:t.hasClass(s,this.clsLeave)?!1:this.cls?t.hasClass(s,this.cls.split(" ")[0]):t.isVisible(s)},_toggle(s,i){if(!s)return;i=!!i;let e;this.cls?(e=t.includes(this.cls," ")||i!==t.hasClass(s,this.cls),e&&t.toggleClass(s,this.cls,t.includes(this.cls," ")?void 0:i)):(e=i===s.hidden,e&&(s.hidden=!i)),t.$$("[autofocus]",s).some(o=>t.isVisible(o)?o.focus()||!0:o.blur()),e&&t.trigger(s,"toggled",[i,this])}}};function O(s,i,{_toggle:e}){return t.Animation.cancel(s),t.Transition.cancel(s),e(s,i)}async function B(s,i,{animation:e,duration:o,velocity:n,transition:a,_toggle:r}){var c;const[h="reveal",b="top"]=((c=e[0])==null?void 0:c.split("-"))||[],T=[["left","right"],["top","bottom"]],y=T[t.includes(T[0],b)?0:1],$=y[1]===b,m=["width","height"][T.indexOf(y)],d="margin-".concat(y[0]),w="margin-".concat(b);let g=t.dimensions(s)[m];const U=t.Transition.inProgress(s);await t.Transition.cancel(s),i&&r(s,!0);const j=Object.fromEntries(["padding","border","width","height","minWidth","minHeight","overflowY","overflowX",d,w].map(A=>[A,s.style[A]])),l=t.dimensions(s),P=t.toFloat(t.css(s,d)),E=t.toFloat(t.css(s,w)),f=l[m]+E;!U&&!i&&(g+=E);const[v]=t.wrapInner(s,"<div>");t.css(v,{boxSizing:"border-box",height:l.height,width:l.width,...t.css(s,["overflow","padding","borderTop","borderRight","borderBottom","borderLeft","borderImage",w])}),t.css(s,{padding:0,border:0,minWidth:0,minHeight:0,[w]:0,width:l.width,height:l.height,overflow:"hidden",[m]:g});const x=g/f;o=(n*f+o)*(i?1-x:x);const C={[m]:i?f:0};$&&(t.css(s,d,f-g+P),C[d]=i?P:f+P),!$^h==="reveal"&&(t.css(v,d,-f+g),t.Transition.start(v,{[d]:i?0:-f},o,a));try{await t.Transition.start(s,C,o,a)}finally{t.css(s,j),t.unwrap(v.firstChild),i||r(s,!1)}}function I(s,i,e){t.Animation.cancel(s);const{animation:o,duration:n,_toggle:a}=e;return i?(a(s,!0),t.Animation.in(s,o[0],n,e.origin)):t.Animation.out(s,o[1]||o[0],n,e.origin).then(()=>a(s,!1))}var D={props:{pos:String,offset:null,flip:Boolean,shift:Boolean,inset:Boolean},data:{pos:"bottom-".concat(t.isRtl?"right":"left"),offset:!1,flip:!0,shift:!0,inset:!1},connected(){this.pos=this.$props.pos.split("-").concat("center").slice(0,2),[this.dir,this.align]=this.pos,this.axis=t.includes(["top","bottom"],this.dir)?"y":"x"},methods:{positionAt(s,i,e){let o=[this.getPositionOffset(s),this.getShiftOffset(s)];const n=[this.flip&&"flip",this.shift&&"shift"],a={element:[this.inset?this.dir:t.flipPosition(this.dir),this.align],target:[this.dir,this.align]};if(this.axis==="y"){for(const h in a)a[h].reverse();o.reverse(),n.reverse()}const r=N(s),c=t.dimensions(s);t.css(s,{top:-c.height,left:-c.width}),t.positionAt(s,i,{attach:a,offset:o,boundary:e,placement:n,viewportOffset:this.getViewportOffset(s)}),r()},getPositionOffset(s){return t.toPx(this.offset===!1?t.css(s,"--uk-position-offset"):this.offset,this.axis==="x"?"width":"height",s)*(t.includes(["left","top"],this.dir)?-1:1)*(this.inset?-1:1)},getShiftOffset(s){return this.align==="center"?0:t.toPx(t.css(s,"--uk-position-shift-offset"),this.axis==="y"?"width":"height",s)*(t.includes(["left","top"],this.align)?1:-1)},getViewportOffset(s){return t.toPx(t.css(s,"--uk-position-viewport-offset"))}}};function N(s){const i=t.scrollParent(s),{scrollTop:e}=i;return()=>{e!==i.scrollTop&&(i.scrollTop=e)}}const _={TAB:9,ESC:27,SPACE:32,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40};function k(s,i=s.$el,e=""){if(i.id)return i.id;let o="".concat(s.$options.id,"-").concat(s._uid).concat(e);return t.$("#".concat(o))&&(o=k(s,i,"".concat(e,"-2"))),o}var u={mixins:[p,S,D],args:"title",props:{delay:Number,title:String},data:{pos:"top",title:"",delay:0,animation:["uk-animation-scale-up"],duration:100,cls:"uk-active"},beforeConnect(){this.id=k(this,{}),this._hasTitle=t.hasAttr(this.$el,"title"),t.attr(this.$el,{title:"","aria-describedby":this.id}),F(this.$el)},disconnected(){this.hide(),t.attr(this.$el,"title")||t.attr(this.$el,"title",this._hasTitle?this.title:null)},methods:{show(){this.isToggled(this.tooltip||null)||!this.title||(clearTimeout(this.showTimer),this.showTimer=setTimeout(this._show,this.delay))},async hide(){t.matches(this.$el,"input:focus")||(clearTimeout(this.showTimer),this.isToggled(this.tooltip||null)&&await this.toggleElement(this.tooltip,!1,!1),t.remove(this.tooltip),this.tooltip=null)},async _show(){this.tooltip=t.append(this.container,'<div id="'.concat(this.id,'" class="uk-').concat(this.$options.name,'" role="tooltip">\n                    <div class="uk-').concat(this.$options.name,'-inner">').concat(this.title,"</div>\n                 </div>")),t.on(this.tooltip,"toggled",(s,i)=>{if(!i)return;const e=()=>this.positionAt(this.tooltip,this.$el);e();const[o,n]=L(this.tooltip,this.$el,this.pos);this.origin=this.axis==="y"?"".concat(t.flipPosition(o),"-").concat(n):"".concat(n,"-").concat(t.flipPosition(o));const a=[t.once(document,"keydown ".concat(t.pointerDown),this.hide,!1,r=>r.type===t.pointerDown&&!t.within(r.target,this.$el)||r.type==="keydown"&&r.keyCode===_.ESC),t.on([document,...t.overflowParents(this.$el)],"scroll",e,{passive:!0})];t.once(this.tooltip,"hide",()=>a.forEach(r=>r()),{self:!0})}),await this.toggleElement(this.tooltip,!0)||this.hide()}},events:{focus:"show",blur:"hide",["".concat(t.pointerEnter," ").concat(t.pointerLeave)](s){t.isTouch(s)||this[s.type===t.pointerEnter?"show":"hide"]()},[t.pointerDown](s){t.isTouch(s)&&this.show()}}};function F(s){t.isFocusable(s)||t.attr(s,"tabindex","0")}function L(s,i,[e,o]){const n=t.offset(s),a=t.offset(i),r=[["left","right"],["top","bottom"]];for(const h of r){if(n[h[0]]>=a[h[1]]){e=h[1];break}if(n[h[1]]<=a[h[0]]){e=h[0];break}}const c=t.includes(r[0],e)?r[1]:r[0];return n[c[0]]===a[c[0]]?o=c[0]:n[c[1]]===a[c[1]]?o=c[1]:o="center",[e,o]}return typeof window<"u"&&window.UIkit&&window.UIkit.component("tooltip",u),u});
